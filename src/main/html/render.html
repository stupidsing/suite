<meta charset='utf-8'>
<!--
file:///home/ywsing/suite/src/main/html/render.html
-->
<!DOCTYPE html>
<html>
	<body>
		<style>
			.overlay {
				background-color: white;
				bottom: 0;
				left: 0;
				position: fixed;
				right: 0;
				top: 0;
				opacity: 0.8;
				z-index: 9998;
			}
		</style>
		<div id='target'></div>
	</body>

	<script src='eval-script.js'></script>
	<script src='frp.js'></script>

	<script type='text/javascript'>
'use strict';

Promise.resolve({})
.then(ns => evalscript('fun.js').then(m => ({ ...ns, fun: m, })))
.then(ns => evalscript('render.js').then(m => ({ ...ns, render: m, })))
.then(ns => {
	let { fun: { lens, read, }, render: { rd, renderAgain, }, } = ns;

	let view;

	let component = (path, publicf, privatef, xhtml) => {
		let change = f => renderAgain(view, vm => {
			let vm_ = vm != null ? vm[path] : null;
			return ({ ...vm, [path]: f(vm_), });
		});
		return {
			view: rd.parse(privatef(change), `<rd_map v='vm.${path}'>${xhtml}</rd_map>`),
			...publicf(change),
		};
	};

	let componentLogin = (overlay, unoverlay) => {
		let fetchBase = { cache: 'no-cache', credentials: 'omit', redirect: 'follow', referrer: 'no-referrer', };

		let login = ({ username, password, }) => {
			console.log('login()', username);

			return Promise
			.resolve()
			.then(overlay)
			.then(() => fetch('../token', {
				...fetchBase,
				mode: 'no-cors',
				body: JSON.stringify({ username, password, }),
				headers: { 'Content-Type': 'application/json', },
				method: 'POST',
			}))
			.then(response => {
				if (response.ok) return response.json(); else throw response.statusText;
			})
			.then(json => json.token)
			.then(token => fetch('../token', {
				...fetchBase,
				headers: { 'Authorization': token, },
				method: 'PATCH',
			}))
			.then(response => {
				if (response.ok) return response.json(); else throw response.statusText;
			})
			.then(json => json.token)
			.then(token => fetch('../api', {
				...fetchBase,
				headers: { 'Authorization': token, },
				method: 'GET',
			})
			.then(response => {
				if (response.ok) return response.text(); else throw response.statusText;
			})
			.then(message => {
				renderAgain(view, vm => ({ ...vm, message, }));
				console.log('login() = ', message);
				return token;
			}))
			.catch(error => {
				console.error('login()', error);
				return 'error';
			})
			.finally(unoverlay);
		};

		return rd.span_component(
			vm => ({ username: 'ywsing', password: '' }),
			({}) => ({}),
			({ change, changeAsync, }) => ({
				setUsername: username => change(vm => ({ ...vm, username, })),
				setPassword: password => change(vm => ({ ...vm, password, })),
				handleLogin: () => changeAsync(vm => login(vm).then(token => ({ ...vm, username: '', password: '', token, }))),
			}),
			`
				<font face='Monospac821 BT, Monaco, Consolas'>
					<form name='login'>
						Username <input rd_on_input='env.setUsername(ev.target.value)' value='{ vm.username }' type='text' autofocus='autofocus' /><br />
						Password <input rd_on_input='env.setPassword(ev.target.value)' value='{ vm.password }' type='password' /><br />
						<input type='button' value='Login' rd_on_click='env.handleLogin()' /><br />
						token: { vm.token }
					</form>
				</font>
			`);
	};

	let componentNotification = component(
		'notification',
		change => ({
			init: () => change(vm => ({ message: '', })),
			deinit: () => change(vm => null),
			setMessage: token => change(vm => ({ ...vm, message, })),
		}),
		change => ({}),
		`
			<div style='
				background: #DDDDDD;
				bottom: 0;
				font-family: Oswald, monospace;
				left: 0;
				position: fixed;
				text-align: center;
				width: 100%;'>
				<p>{ vm.message }</p>
			</div>
		`,
	);

	let componentOverlay = rd.span_component(
		vm => ({ count: 0, }),
		({ change, }) => ({
			enable: token => change(vm => ({ ...vm, count: vm.count + 1, })),
			disable: token => change(vm => ({ ...vm, count: vm.count - 1, })),
		}),
		change => ({}),
		`<div class='{ vm.count !== 0 ? "overlay" : "" }'></div>`,
	);

	let componentLoginOverlay = vm => {
		let co = componentOverlay(vm);
		let cl = componentLogin(co.enable, co.disable)(vm);
		return {
			init: cudf => {
				co.init(cudf);
				cl.init(cudf);
			},
			deinit: cudf => {
				cl.deinit(cudf);
				co.deinit(cudf);
			},
		};
	};

	let view0 = rd.parse({
		componentLoginOverlay,
		componentNotification,
	}, `
		<span style='font-family: sans-serif;'>
			<rd_map v='true'>
				<rd_component v='env.componentLoginOverlay' />
			</rd_map>
			<rd_view v='env.componentNotification.view' />

			<rd_map v='vm.message'>
				<p style='font-weight: bold;'>
					{ vm } within scope
					<!-- comment -->
				</p>
			</rd_map>
			<rd_map v='vm.t'>
				{ vm }
			</rd_map>
			<ul>
				<rd_for v='vm.fruits'><li>{ vm }</li></rd_for>
			</ul>
			<div>
				<!--rd_map v='vm.sse'>server sent events: <rd_for>{ vm }</rd_for></rd_map-->
			</div>
			<div style='
				background-color: rgb(0, 0, 0);
				background-color: rgb(0, 0, 0, 0.4);
				display: { vm.isPopup ? "block" : "none" };
				height: 100%;
				left: 0;
				overflow: auto;
				position: fixed;
				top: 0;
				width: 100%;
				z-index: 1;'>
				<div style='
					background-color: #FEFEFE;
					border: 1px solid #888;
					margin: 15% auto;
					padding: 20px;
					width: 50%;'>
					<span rd_on_click='messager(false)'
						style='
						cursor: pointer;
						font-size: 28px;
						float: right;'>
						Ã—
					</span>
					<p>Climb every mountain</p>
					<p>Another</p>
				</div>
			</div>
			<button rd_on_click='messager(true)'>Message</button>
			<button rd_on_click='closer()'>Close</button>
		</span>
	`);

	let view1 = rd.span().children(
		rd.map(vm => vm.message,
			rd.p().style({ 'font-weight': 'bold', }).text().rd()
		),
		rd.map(vm => vm.t,
			rd.p().text().rd()
		),
		rd.map(vm => vm.fruits,
			rd.ul().child(rd.for(vm => vm, rd.li().text().rd())).rd()
		),
		rd.tag('button').child(rd.dom(vm => document.createTextNode('Close'))).listen('click', ev => closer()).rd(),
	).rd();

	view = rd
		.span()
		.style({ 'font-family': 'sans-serif', })
		.child(
			rd.list([
				view0,
				view1,
				rd.p().rd(),
				rd.map(vm => vm.vscroll, rd
					.vscrollf(200, 32,
						rd.dom(vm => document.createTextNode('item ' + vm)),
						start1 => renderAgain(view, lens.key('vscroll').key('start').apply(start0 => start1)),
					)
					.style({ width: '400px', })
					.rd()
				),
			]),
		)
		.rd();

	let sse = [];
	let t = 0;
	let vscroll = { start: 0, vms: read().range(0, 256).list(), };

	let upd0 = lens.key('t').apply(t => t + 1);
	let upd1 = lens.key('vscroll').key('vms').index(3).apply(vm => Math.random().toString());

	let interval0 = setInterval(() => renderAgain(view, upd0), 1000);
	let interval1 = setInterval(() => renderAgain(view, upd1), 3000);

	componentNotification.init();
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world0', fruits: ['banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world1', fruits: ['apple', 'banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world2', fruits: ['apple', 'orange', 'orange', 'banana',], }));
	renderAgain(view, vm => ({ ...vm, sse, t, vscroll, message: 'hello world~', fruits: ['banana', 'orange',], }));

	globalThis.closer = () => {
		clearInterval(interval0);
		clearInterval(interval1);
		renderAgain(view, vm => null);
	};

	globalThis.messager = b => renderAgain(view, vm => ({ ...vm, isPopup: b }));

	let eventSource = new EventSource('/sse');

	eventSource.onError = error => console.log(error);
	eventSource.onMessage = event => console.log(event);

	eventSource.addEventListener("close", ev => eventSource.close());
	eventSource.addEventListener("number", ev => renderAgain(view, vm => ({ ...vm, sse: [...vm.sse, JSON.parse(ev.data).i,], })));
});

	</script>
</html>
