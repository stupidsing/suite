<meta charset='utf-8'>
<!--
file:///home/ywsing/suite/src/main/html/five-in-a-row.html
-->
<!DOCTYPE html>
<html>
	<head>
		<title>0 - Five in a row</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
	</head>
	<body>
		<div id='target'></div>
	</body>

	<script src='frp.js'></script>
	<script src='fun.js'></script>
	<script src='pq.js'></script>
	<script src='render.js'></script>

	<script type='text/javascript'>
'use strict';

let { lens, range, read, } = fun();
let { rd, renderAgain, } = render();
let close;

let viewCell = rd.parse(`
	<div draggable='true'
		style='
			background: { vm.selected ? "#888888" : "#DDDDDD" };
			display: table-cell;
			font-size: 25px;
			height: 40px;
			text-align: center;
			vertical-align: middle;
			width: 40px;
		'
		rd_on_click='handleclick(vm, ev)'>
		<rd_if v='vm.d &lt; 0'><font color='grey'>ğŸ’€</font></rd_if>
		<rd_if v='vm.d == 0'><font color='yellow'>ğŸ‹</font></rd_if><!-- ğŸ˜‚ -->
		<rd_if v='vm.d == 1'><font color='green'>ğŸŒ²</font></rd_if>
		<rd_if v='vm.d == 2'><font color='red'>ğŸ’–</font></rd_if>
		<rd_if v='vm.d == 3'><font color='blue'>ğŸ¬</font></rd_if>
		<rd_if v='vm.d == 4'><font color='brown'>ğŸµ</font></rd_if>
		<rd_if v='vm.d == 5'><font color='orange'>ğŸŠ</font></rd_if>
		<rd_if v='vm.d == 6'><font color='purple'>ğŸ‡</font></rd_if>
		<rd_if v='vm.d == 7'><font color='white'>ğŸ’®</font></rd_if>
		<rd_if v='vm.d == 8'><font color='black'>âœ´ï¸</font></rd_if>
	</div>
`);

let view = rd.parse(`
	<span>
		<rd_map v='vm.nextstones'>
			<table style='font-family: monospace; font-size: 20; user-select: none;'>
				<tr>
					<rd_for>
						<td><rd_component v='viewCell' /></td>
					</rd_for>
				</tr>
			</table>
		</rd_map>
		<p/>
		<rd_map v='vm.board'>
			<table style='font-family: monospace; font-size: 20; user-select: none;'>
				<rd_for>
					<tr>
						<rd_for>
							<td><rd_component v='viewCell' /></td>
						</rd_for>
					</tr>
				</rd_for>
			</table>
		</rd_map>
		<button rd_on_click='close()'>Close</button>
	</span>
`);

const usp = new URLSearchParams(window.location.search);
const colorsp = usp.get('colors');
const sizep = usp.get('size');

let size = sizep != null ? +sizep : 7;
let nStoneTypes = colorsp != null ? +colorsp : 5;
let score = 0;

let randomstone = () => ({ d: Math.floor(Math.random() * nStoneTypes) });

let randomstones = n => {
	let stones = [];
	for (let i = 0; i < n; i++) stones.push(randomstone());
	return stones;
};

let search = (xy0, xyx, isMovable) => {
	let key = xy => `${xy.x},${xy.y}`;
	let todos = [{ x: xy0.x, y: xy0.y, prev: null, }];
	let dones = {};
	let kx = key(xyx);
	while (0 < todos.length) { // breadth-first search
		let todo = todos.shift();
		let { x, y, } = todo;
		let k = key(todo);
		if (!dones.hasOwnProperty(k)) {
			let neighbours = [[-1, 0], [+1, 0], [0, -1], [0, +1],]
				.map(([dx, dy]) => ({ x: x + dx, y: y + dy, prev: todo, }))
				.filter(({ x, y }) => 0 <= x && x < size && 0 <= y && y < size && isMovable(x, y));
			todos.push(...neighbours);
			dones[k] = todo;
			if (k == kx) return todo;
		}
	}
	return null;
};

let freeze = false;
let select_xy = null;

let vm_ = {
	setcell: (vm, vmc1) =>  {
		let vmt0 = vm.board;
		let vmr0 = vmt0[vmc1.x];
		let vmc0 = vmr0[vmc1.y];
		let vmr1 = vmr0.map(vmc => vmc != vmc0 ? vmc : vmc1);
		let vmt1 = vmt0.map(vmr => vmr != vmr0 ? vmr : vmr1);
		return { ...vm, board: vmt1 };
	},
	emptycount: vm => {
		let n = 0;
		for (let x = 0; x < size; x++)
			for (let y = 0; y < size; y++)
				n += vm.board[x][y].d != null ? 0 : 1;
		return n;
	},
	lose: vm => {
		freeze = true;
		for (let x = 0; x < size; x++)
			for (let y = 0; y < size; y++)
				if (vm.board[x][y].d == null)
					vm = vm_.setcell(vm, { ...vm.board[x][y], d: -1 });
		return vm;
	},
	drop: (vm, stones) => {
		if (stones.length <= vm_.emptycount(vm))
			for (let stone of stones)
				while(true) {
					let x = Math.floor(Math.random() * size);
					let y = Math.floor(Math.random() * size);
					if (vm.board[x][y].d == null) {
						vm = vm_.setcell(vm, { ...vm.board[x][y], d: stone.d });
						break;
					}
				}
		else
			vm = vm_.lose(vm);
		return vm;
	},
};

let vw = {
	change: f => {
		renderAgain(view, vm0 => {
			let vm1 = f(vm0);
			// console.log(vm1);
			return vm1;
		});
	},
	init: () => vw.change(vm0 => {
		var vm1 = {
			board: range(0, size).map(x => range(0, size).map(y => ({ d: null, x, y, })).list()).list(),
			nextstones: [randomstone(), randomstone(), randomstone(),],
		};
		return vm_.drop(vm1, randomstones(Math.ceil(size * size * .3)));
	}),
	unselect: () => {
		vw.change(vm => {
			let vmc = vm.board[select_xy.x][select_xy.y];
			return vm_.setcell(vm, { ...vmc, selected: false, });
		});
		select_xy = null;
	},
	select: (x, y) => {
		vw.change(vm => {
			let vmc = vm.board[x][y];
			return vm_.setcell(vm, { ...vmc, selected: true, });
		});
		select_xy = { x, y };
	},
};

let check = () => {
	let isFiveInARow = false;
	if (!freeze)
		vw.change(vm => {
			for (let x = 0; x < size; x++)
				for (let y = 0; y < size; y++)
					for (let [dx, dy] of [[0, 1], [1, 0], [-1, 1], [1, 1],]) {
						let step = 0;
						let x1, y1;
						while (true
							&& (x1 = x + step * dx) != null
							&& (y1 = y + step * dy) != null
							&& 0 <= x1 && x1 < size && 0 <= y1 && y1 < size
							&& vm.board[x][y].d != null
							&& vm.board[x][y].d == vm.board[x1][y1].d) step++;
						if (5 <= step) {
							isFiveInARow = true;
							for (let i = 0; i < step; i++)
								vm = vm_.setcell(vm, { ...vm.board[x + i * dx][y + i * dy], d: null, });
							score += step;
							document.title = `${score} - Five in a row`;
						}
					}
			return vm;
		});
	return isFiveInARow;
};

let move = (vm, vmc0, vmcx) => {
	let node = search(vmc0, vmcx, (x, y) => vm.board[x][y].d == null);
	let rec = ({ x, y, prev, }, cb) => {
		if (prev != null)
			rec(prev, () => {
				let timeout = setTimeout(() => {
					vw.change(vm => {
						let vmc0 = vm.board[prev.x][prev.y];
						let vmc1 = vm.board[x][y];
						let d = vmc0.d;
						vm = vm_.setcell(vm, { ...vmc0, d: null, });
						vm = vm_.setcell(vm, { ...vmc1, d, });
						return vm;
					});
					cb();
					clearTimeout(timeout);
				}, 50);
			});
		else
			cb();
	};
	if (node != null) {
		freeze = true;
		rec(node, () => {
			freeze = false;
			if (!check()) {
				vw.change(vm => {
					vm = vm_.drop(vm, vm.nextstones);
					return { ...vm, nextstones: randomstones(3), };
				});
				check();
			}				
		});
	} else
		console.log('no path between', vmc0, vmcx);
};

let handleclick = (vmc, ev) => {
	if (!freeze) {
		let select_xy0 = select_xy;

		if (select_xy != null) vw.unselect();

		if (vmc.d != null)
			vw.select(vmc.x, vmc.y);
		else if (select_xy0 != null) {
			let vm_;
			vw.change(vm => vm_ = vm);
			move(vm_, select_xy0, vmc);
		}
	}
};

vw.init();

close = () => vw.change(vm => null);

	</script>
</html>
